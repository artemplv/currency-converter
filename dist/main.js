!(function () {
  'use strict';

  !(function () {
    const n = 1e-6; const t = 1e-12; const e = Math.PI; const i = e / 2; const r = e / 4; const o = 2 * e; const u = 180 / e; const l = e / 180; const a = Math.abs; const c = Math.atan; const s = Math.atan2; const f = Math.cos; const h = (Math.ceil, Math.exp, Math.floor, Math.hypot, Math.log, Math.pow, Math.sin); const p = Math.sign || function (n) { return n > 0 ? 1 : n < 0 ? -1 : 0; }; const d = Math.sqrt; function v(n) { return n > 1 ? i : n < -1 ? -i : Math.asin(n); } function g() {} function S() {
      let n; let t = []; return {
        point(t, e, i) { n.push([t, e, i]); }, lineStart() { t.push(n = []); }, lineEnd: g, rejoin() { t.length > 1 && t.push(t.pop().concat(t.shift())); }, result() { const e = t; return t = [], n = null, e; },
      };
    } function y(t, e) { return a(t[0] - e[0]) < n && a(t[1] - e[1]) < n; } function m(n, t, e, i) { this.x = n, this.z = t, this.o = e, this.e = i, this.v = !1, this.n = this.p = null; } function E(t, e, i, r, o) { let u; let l; const a = []; const c = []; if (t.forEach(((t) => { if (!((e = t.length - 1) <= 0)) { var e; let i; let r = t[0]; const l = t[e]; if (y(r, l)) { if (!r[2] && !l[2]) { for (o.lineStart(), u = 0; u < e; ++u)o.point((r = t[u])[0], r[1]); return void o.lineEnd(); }l[0] += 2 * n; }a.push(i = new m(r, t, null, !0)), c.push(i.o = new m(r, null, i, !1)), a.push(i = new m(l, t, null, !1)), c.push(i.o = new m(l, null, i, !0)); } })), a.length) { for (c.sort(e), M(a), M(c), u = 0, l = c.length; u < l; ++u)c[u].e = i = !i; for (var s, f, h = a[0]; ;) { for (var p = h, d = !0; p.v;) if ((p = p.n) === h) return; s = p.z, o.lineStart(); do { if (p.v = p.o.v = !0, p.e) { if (d) for (u = 0, l = s.length; u < l; ++u)o.point((f = s[u])[0], f[1]); else r(p.x, p.n.x, 1, o); p = p.n; } else { if (d) for (s = p.p.z, u = s.length - 1; u >= 0; --u)o.point((f = s[u])[0], f[1]); else r(p.x, p.p.x, -1, o); p = p.p; }s = (p = p.o).z, d = !d; } while (!p.v); o.lineEnd(); } } } function M(n) { if (t = n.length) { for (var t, e, i = 0, r = n[0]; ++i < t;)r.n = e = n[i], e.p = r, r = e; r.n = e = n[0], e.p = r; } }Math.tan; class _ {
      constructor() { this._partials = new Float64Array(32), this._n = 0; }

      add(n) { const t = this._partials; let e = 0; for (let i = 0; i < this._n && i < 32; i++) { const r = t[i]; const o = n + r; const u = Math.abs(n) < Math.abs(r) ? n - (o - r) : r - (o - n); u && (t[e++] = u), n = o; } return t[e] = n, this._n = e + 1, this; }

      valueOf() { const n = this._partials; let t; let e; let i; let r = this._n; let o = 0; if (r > 0) { for (o = n[--r]; r > 0 && (t = o, e = n[--r], o = t + e, i = e - (o - t), !i););r > 0 && (i < 0 && n[r - 1] < 0 || i > 0 && n[r - 1] > 0) && (e = 2 * i, t = o + e, e == t - o && (o = t)); } return o; }
    } function w(n) { return [s(n[1], n[0]), v(n[2])]; } function x(n) { const t = n[0]; const e = n[1]; const i = f(e); return [i * f(t), i * h(t), h(e)]; } function C(n, t) { return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]; } function b(n, t) { return [n[1] * t[2] - n[2] * t[1], n[2] * t[0] - n[0] * t[2], n[0] * t[1] - n[1] * t[0]]; } function L(n, t) { n[0] += t[0], n[1] += t[1], n[2] += t[2]; } function N(n, t) { return [n[0] * t, n[1] * t, n[2] * t]; } function P(n) { const t = d(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]); n[0] /= t, n[1] /= t, n[2] /= t; } function $(n) { return a(n[0]) <= e ? n[0] : p(n[0]) * ((a(n[0]) + e) % o - e); } function k(u, l) { const a = $(l); let c = l[1]; const p = h(c); const d = [h(a), -f(a), 0]; let g = 0; let S = 0; const y = new _(); p === 1 ? c = i + n : p === -1 && (c = -i - n); for (let m = 0, E = u.length; m < E; ++m) if (w = (M = u[m]).length) for (var M, w, C = M[w - 1], L = $(C), N = C[1] / 2 + r, k = h(N), T = f(N), j = 0; j < w; ++j, L = z, k = F, T = G, C = R) { var R = M[j]; var z = $(R); const D = R[1] / 2 + r; var F = h(D); var G = f(D); const Y = z - L; const O = Y >= 0 ? 1 : -1; const X = O * Y; const Z = X > e; const q = k * F; if (y.add(s(q * O * h(X), T * G + q * f(X))), g += Z ? Y + O * o : Y, Z ^ L >= a ^ z >= a) { const A = b(x(C), x(R)); P(A); const U = b(d, A); P(U); const V = (Z ^ Y >= 0 ? -1 : 1) * v(U[2]); (c > V || c === V && (A[0] || A[1])) && (S += Z ^ Y >= 0 ? 1 : -1); } } return (g < -n || g < n && y < -t) ^ 1 & S; } function T(n) { return Array.from(function* (n) { for (const t of n) yield* t; }(n)); } function j(n, t, e, i) {
      return function (r) {
        let o; let u; let l; const a = t(r); const c = S(); const s = t(c); let f = !1; var h = {
          point: p, lineStart: v, lineEnd: g, polygonStart() { h.point = y, h.lineStart = m, h.lineEnd = M, u = [], o = []; }, polygonEnd() { h.point = p, h.lineStart = v, h.lineEnd = g, u = T(u); const n = k(o, i); u.length ? (f || (r.polygonStart(), f = !0), E(u, z, n, e, r)) : n && (f || (r.polygonStart(), f = !0), r.lineStart(), e(null, null, 1, r), r.lineEnd()), f && (r.polygonEnd(), f = !1), u = o = null; }, sphere() { r.polygonStart(), r.lineStart(), e(null, null, 1, r), r.lineEnd(), r.polygonEnd(); },
        }; function p(t, e) { n(t, e) && r.point(t, e); } function d(n, t) { a.point(n, t); } function v() { h.point = d, a.lineStart(); } function g() { h.point = p, a.lineEnd(); } function y(n, t) { l.push([n, t]), s.point(n, t); } function m() { s.lineStart(), l = []; } function M() { y(l[0][0], l[0][1]), s.lineEnd(); let n; let t; let e; let i; const a = s.clean(); const h = c.result(); const p = h.length; if (l.pop(), o.push(l), l = null, p) if (1 & a) { if ((t = (e = h[0]).length - 1) > 0) { for (f || (r.polygonStart(), f = !0), r.lineStart(), n = 0; n < t; ++n)r.point((i = e[n])[0], i[1]); r.lineEnd(); } } else p > 1 && 2 & a && h.push(h.pop().concat(h.shift())), u.push(h.filter(R)); } return h;
      };
    } function R(n) { return n.length > 1; } function z(t, e) { return ((t = t.x)[0] < 0 ? t[1] - i - n : i - t[1]) - ((e = e.x)[0] < 0 ? e[1] - i - n : i - e[1]); } const D = j((() => !0), ((t) => {
      let r; let o = NaN; let u = NaN; let l = NaN; return {
        lineStart() { t.lineStart(), r = 1; }, point(s, p) { const d = s > 0 ? e : -e; const v = a(s - o); a(v - e) < n ? (t.point(o, u = (u + p) / 2 > 0 ? i : -i), t.point(l, u), t.lineEnd(), t.lineStart(), t.point(d, u), t.point(s, u), r = 0) : l !== d && v >= e && (a(o - l) < n && (o -= l * n), a(s - d) < n && (s -= d * n), u = (function (t, e, i, r) { let o; let u; const l = h(t - i); return a(l) > n ? c((h(e) * (u = f(r)) * h(i) - h(r) * (o = f(e)) * h(t)) / (o * u * l)) : (e + r) / 2; }(o, u, s, p)), t.point(l, u), t.lineEnd(), t.lineStart(), t.point(d, u), r = 0), t.point(o = s, u = p), l = d; }, lineEnd() { t.lineEnd(), o = u = NaN; }, clean() { return 2 - r; },
      };
    }), ((t, r, o, u) => { let l; if (t == null)l = o * i, u.point(-e, l), u.point(0, l), u.point(e, l), u.point(e, 0), u.point(e, -l), u.point(0, -l), u.point(-e, -l), u.point(-e, 0), u.point(-e, l); else if (a(t[0] - r[0]) > n) { const c = t[0] < r[0] ? e : -e; l = o * c / 2, u.point(-c, l), u.point(0, l), u.point(c, l); } else u.point(r[0], r[1]); }), [-e, -i]); function F(t, i) { (i = x(i))[0] -= t, P(i); let r; const u = (r = -i[1]) > 1 ? 0 : r < -1 ? e : Math.acos(r); return ((-i[2] < 0 ? -u : u) + o - n) % o; } const G = 1e9; const Y = -G; function O(n, t) { function e(e, i) { return e = n(e, i), t(e[0], e[1]); } return n.invert && t.invert && (e.invert = function (e, i) { return (e = t.invert(e, i)) && n.invert(e[0], e[1]); }), e; } const X = (n) => n; function Z(n, t) { return a(n) > e && (n -= Math.round(n / o) * o), [n, t]; } function q(n) { return function (t, i) { return a(t += n) > e && (t -= Math.round(t / o) * o), [t, i]; }; } function A(n) { const t = q(n); return t.invert = q(-n), t; } function U(n, t) { const e = f(n); const i = h(n); const r = f(t); const o = h(t); function u(n, t) { const u = f(t); const l = f(n) * u; const a = h(n) * u; const c = h(t); const p = c * e + l * i; return [s(a * r - p * o, l * e - c * i), v(p * r + a * o)]; } return u.invert = function (n, t) { const u = f(t); const l = f(n) * u; const a = h(n) * u; const c = h(t); const p = c * r - a * o; return [s(a * r + c * o, l * e + p * i), v(p * e - l * i)]; }, u; } function V(n) { return function (t) { const e = new W(); for (const i in n)e[i] = n[i]; return e.stream = t, e; }; } function W() {} function B(n, t) { n && I.hasOwnProperty(n.type) && I[n.type](n, t); }Z.invert = Z, W.prototype = {
      constructor: W, point(n, t) { this.stream.point(n, t); }, sphere() { this.stream.sphere(); }, lineStart() { this.stream.lineStart(); }, lineEnd() { this.stream.lineEnd(); }, polygonStart() { this.stream.polygonStart(); }, polygonEnd() { this.stream.polygonEnd(); },
    }; const H = { Feature(n, t) { B(n.geometry, t); }, FeatureCollection(n, t) { for (let e = n.features, i = -1, r = e.length; ++i < r;)B(e[i].geometry, t); } }; var I = {
      Sphere(n, t) { t.sphere(); }, Point(n, t) { n = n.coordinates, t.point(n[0], n[1], n[2]); }, MultiPoint(n, t) { for (let e = n.coordinates, i = -1, r = e.length; ++i < r;)n = e[i], t.point(n[0], n[1], n[2]); }, LineString(n, t) { K(n.coordinates, t, 0); }, MultiLineString(n, t) { for (let e = n.coordinates, i = -1, r = e.length; ++i < r;)K(e[i], t, 0); }, Polygon(n, t) { J(n.coordinates, t); }, MultiPolygon(n, t) { for (let e = n.coordinates, i = -1, r = e.length; ++i < r;)J(e[i], t); }, GeometryCollection(n, t) { for (let e = n.geometries, i = -1, r = e.length; ++i < r;)B(e[i], t); },
    }; function K(n, t, e) { let i; let r = -1; const o = n.length - e; for (t.lineStart(); ++r < o;)i = n[r], t.point(i[0], i[1], i[2]); t.lineEnd(); } function J(n, t) { let e = -1; const i = n.length; for (t.polygonStart(); ++e < i;)K(n[e], t, 1); t.polygonEnd(); } function Q(n, t) { n && H.hasOwnProperty(n.type) ? H[n.type](n, t) : B(n, t); } let nn = 1 / 0; let tn = nn; let en = -nn; let rn = en; const on = {
      point(n, t) { n < nn && (nn = n), n > en && (en = n), t < tn && (tn = t), t > rn && (rn = t); }, lineStart: g, lineEnd: g, polygonStart: g, polygonEnd: g, result() { const n = [[nn, tn], [en, rn]]; return en = rn = -(tn = nn = 1 / 0), n; },
    }; const un = on; function ln(n, t, e) { const i = n.clipExtent && n.clipExtent(); return n.scale(150).translate([0, 0]), i != null && n.clipExtent(null), Q(e, n.stream(un)), t(un.result()), i != null && n.clipExtent(i), n; } function an(n, t, e) { return ln(n, ((e) => { const i = t[1][0] - t[0][0]; const r = t[1][1] - t[0][1]; const o = Math.min(i / (e[1][0] - e[0][0]), r / (e[1][1] - e[0][1])); const u = +t[0][0] + (i - o * (e[1][0] + e[0][0])) / 2; const l = +t[0][1] + (r - o * (e[1][1] + e[0][1])) / 2; n.scale(150 * o).translate([u, l]); }), e); } const cn = 16; const sn = f(30 * l); function fn(t, e) {
      return +e ? (function (t, e) {
        function i(r, o, u, l, c, f, h, p, g, S, y, m, E, M) { const _ = h - r; const w = p - o; const x = _ * _ + w * w; if (x > 4 * e && E--) { let C = l + S; let b = c + y; let L = f + m; const N = d(C * C + b * b + L * L); const P = v(L /= N); const $ = a(a(L) - 1) < n || a(u - g) < n ? (u + g) / 2 : s(b, C); const k = t($, P); const T = k[0]; const j = k[1]; const R = T - r; const z = j - o; const D = w * R - _ * z; (D * D / x > e || a((_ * R + w * z) / x - 0.5) > 0.3 || l * S + c * y + f * m < sn) && (i(r, o, u, l, c, f, T, j, $, C /= N, b /= N, L, E, M), M.point(T, j), i(T, j, $, C, b, L, h, p, g, S, y, m, E, M)); } } return function (n) {
          let e; let r; let o; let u; let l; let a; let c; let s; let f; let h; let p; let d; var v = {
            point: g, lineStart: S, lineEnd: m, polygonStart() { n.polygonStart(), v.lineStart = E; }, polygonEnd() { n.polygonEnd(), v.lineStart = S; },
          }; function g(e, i) { e = t(e, i), n.point(e[0], e[1]); } function S() { s = NaN, v.point = y, n.lineStart(); } function y(e, r) { const o = x([e, r]); const u = t(e, r); i(s, f, c, h, p, d, s = u[0], f = u[1], c = e, h = o[0], p = o[1], d = o[2], cn, n), n.point(s, f); } function m() { v.point = g, n.lineEnd(); } function E() { S(), v.point = M, v.lineEnd = _; } function M(n, t) { y(e = n, t), r = s, o = f, u = h, l = p, a = d, v.point = y; } function _() { i(s, f, c, h, p, d, r, o, e, u, l, a, cn, n), v.lineEnd = m, m(); } return v;
        };
      }(t, e)) : (function (n) { return V({ point(t, e) { t = n(t, e), this.stream.point(t[0], t[1]); } }); }(t));
    } let hn; const pn = V({ point(n, t) { this.stream.point(n * l, t * l); } }); function dn(n, t, e, i, r, o) { if (!o) return (function (n, t, e, i, r) { function o(o, u) { return [t + n * (o *= i), e - n * (u *= r)]; } return o.invert = function (o, u) { return [(o - t) / n * i, (e - u) / n * r]; }, o; }(n, t, e, i, r)); const u = f(o); const l = h(o); const a = u * n; const c = l * n; const s = u / n; const p = l / n; const d = (l * e - u * t) / n; const v = (l * t + u * e) / n; function g(n, o) { return [a * (n *= i) - c * (o *= r) + t, e - c * n - a * o]; } return g.invert = function (n, t) { return [i * (s * n - p * t + d), r * (v - p * n - s * t)]; }, g; } function vn(t) {
      return (function (t) {
        let i; let r; let c; let s; let p; let v; let g; let m; let M; let _; let P = 150; let $ = 480; let k = 250; let R = 0; let z = 0; let q = 0; let W = 0; let B = 0; let H = 0; let I = 1; let K = 1; let J = null; let Q = D; let nn = null; let tn = X; let en = 0.5; function rn(n) { return m(n[0] * l, n[1] * l); } function on(n) { return (n = m.invert(n[0], n[1])) && [n[0] * u, n[1] * u]; } function un() { const n = dn(P, 0, 0, I, K, H).apply(null, i(R, z)); const t = dn(P, $ - n[0], k - n[1], I, K, H); return r = (function (n, t, e) { return (n %= o) ? t || e ? O(A(n), U(t, e)) : A(n) : t || e ? U(t, e) : Z; }(q, W, B)), g = O(i, t), m = O(r, g), v = fn(g, en), cn(); } function cn() { return M = _ = null, rn; } return rn.stream = function (n) { return M && _ === n ? M : M = pn((function (n) { return V({ point(t, e) { const i = n(t, e); return this.stream.point(i[0], i[1]); } }); }(r))(Q(v(tn(_ = n))))); }, rn.preclip = function (n) { return arguments.length ? (Q = n, J = void 0, cn()) : Q; }, rn.postclip = function (n) { return arguments.length ? (tn = n, nn = c = s = p = null, cn()) : tn; }, rn.clipAngle = function (t) {
          return arguments.length ? (Q = +t ? (function (t) {
            const i = f(t); const r = 6 * l; const u = i > 0; const c = a(i) > n; function s(n, t) { return f(n) * f(t) > i; } function p(t, r, o) { const u = [1, 0, 0]; const l = b(x(t), x(r)); const c = C(l, l); const s = l[0]; const f = c - s * s; if (!f) return !o && t; const h = i * c / f; const p = -i * s / f; const v = b(u, l); const g = N(u, h); L(g, N(l, p)); const S = v; const y = C(g, S); const m = C(S, S); const E = y * y - m * (C(g, g) - 1); if (!(E < 0)) { const M = d(E); let _ = N(S, (-y - M) / m); if (L(_, g), _ = w(_), !o) return _; let P; let $ = t[0]; let k = r[0]; let T = t[1]; let j = r[1]; k < $ && (P = $, $ = k, k = P); const R = k - $; const z = a(R - e) < n; if (!z && j < T && (P = T, T = j, j = P), z || R < n ? z ? T + j > 0 ^ _[1] < (a(_[0] - $) < n ? T : j) : T <= _[1] && _[1] <= j : R > e ^ ($ <= _[0] && _[0] <= k)) { const D = N(S, (-y + M) / m); return L(D, g), [_, w(D)]; } } } function v(n, i) { const r = u ? t : e - t; let o = 0; return n < -r ? o |= 1 : n > r && (o |= 2), i < -r ? o |= 4 : i > r && (o |= 8), o; } return j(s, ((n) => {
              let t; let i; let r; let o; let l; return {
                lineStart() { o = r = !1, l = 1; }, point(a, f) { let h; const d = [a, f]; const g = s(a, f); const S = u ? g ? 0 : v(a, f) : g ? v(a + (a < 0 ? e : -e), f) : 0; if (!t && (o = r = g) && n.lineStart(), g !== r && (!(h = p(t, d)) || y(t, h) || y(d, h)) && (d[2] = 1), g !== r)l = 0, g ? (n.lineStart(), h = p(d, t), n.point(h[0], h[1])) : (h = p(t, d), n.point(h[0], h[1], 2), n.lineEnd()), t = h; else if (c && t && u ^ g) { let m; S & i || !(m = p(d, t, !0)) || (l = 0, u ? (n.lineStart(), n.point(m[0][0], m[0][1]), n.point(m[1][0], m[1][1]), n.lineEnd()) : (n.point(m[1][0], m[1][1]), n.lineEnd(), n.lineStart(), n.point(m[0][0], m[0][1], 3))); }!g || t && y(t, d) || n.point(d[0], d[1]), t = d, r = g, i = S; }, lineEnd() { r && n.lineEnd(), t = null; }, clean() { return l | (o && r) << 1; },
              };
            }), ((n, e, i, u) => { !(function (n, t, e, i, r, u) { if (e) { const l = f(t); const a = h(t); const c = i * e; r == null ? (r = t + i * o, u = t - c / 2) : (r = F(l, r), u = F(l, u), (i > 0 ? r < u : r > u) && (r += i * o)); for (var s, p = r; i > 0 ? p > u : p < u; p -= c)s = w([l, -a * f(p), -a * h(p)]), n.point(s[0], s[1]); } }(u, t, r, i, n, e)); }), u ? [0, -t] : [-e, t - e]);
          }(J = t * l)) : (J = null, D), cn()) : J * u;
        }, rn.clipExtent = function (t) {
          return arguments.length ? (tn = t == null ? (nn = c = s = p = null, X) : (function (t, e, i, r) {
            function o(n, o) { return t <= n && n <= i && e <= o && o <= r; } function u(n, o, u, a) { let c = 0; let f = 0; if (n == null || (c = l(n, u)) !== (f = l(o, u)) || s(n, o) < 0 ^ u > 0) do { a.point(c === 0 || c === 3 ? t : i, c > 1 ? r : e); } while ((c = (c + u + 4) % 4) !== f); else a.point(o[0], o[1]); } function l(r, o) { return a(r[0] - t) < n ? o > 0 ? 0 : 3 : a(r[0] - i) < n ? o > 0 ? 2 : 1 : a(r[1] - e) < n ? o > 0 ? 1 : 0 : o > 0 ? 3 : 2; } function c(n, t) { return s(n.x, t.x); } function s(n, t) { const e = l(n, 1); const i = l(t, 1); return e !== i ? e - i : e === 0 ? t[1] - n[1] : e === 1 ? n[0] - t[0] : e === 2 ? n[1] - t[1] : t[0] - n[0]; } return function (n) {
              let l; let a; let s; let f; let h; let p; let d; let v; let g; let y; let m; let M = n; const _ = S(); var w = {
                point: x, lineStart() { w.point = C, a && a.push(s = []), y = !0, g = !1, d = v = NaN; }, lineEnd() { l && (C(f, h), p && g && _.rejoin(), l.push(_.result())), w.point = x, g && M.lineEnd(); }, polygonStart() { M = _, l = [], a = [], m = !0; }, polygonEnd() { const e = (function () { for (var n = 0, e = 0, i = a.length; e < i; ++e) for (var o, u, l = a[e], c = 1, s = l.length, f = l[0], h = f[0], p = f[1]; c < s; ++c)o = h, u = p, h = (f = l[c])[0], p = f[1], u <= r ? p > r && (h - o) * (r - u) > (p - u) * (t - o) && ++n : p <= r && (h - o) * (r - u) < (p - u) * (t - o) && --n; return n; }()); const i = m && e; const o = (l = T(l)).length; (i || o) && (n.polygonStart(), i && (n.lineStart(), u(null, null, 1, n), n.lineEnd()), o && E(l, c, e, u, n), n.polygonEnd()), M = n, l = a = s = null; },
              }; function x(n, t) { o(n, t) && M.point(n, t); } function C(n, u) { const l = o(n, u); if (a && s.push([n, u]), y)f = n, h = u, p = l, y = !1, l && (M.lineStart(), M.point(n, u)); else if (l && g)M.point(n, u); else { const c = [d = Math.max(Y, Math.min(G, d)), v = Math.max(Y, Math.min(G, v))]; const S = [n = Math.max(Y, Math.min(G, n)), u = Math.max(Y, Math.min(G, u))]; !(function (n, t, e, i, r, o) { let u; const l = n[0]; const a = n[1]; let c = 0; let s = 1; const f = t[0] - l; const h = t[1] - a; if (u = e - l, f || !(u > 0)) { if (u /= f, f < 0) { if (u < c) return; u < s && (s = u); } else if (f > 0) { if (u > s) return; u > c && (c = u); } if (u = r - l, f || !(u < 0)) { if (u /= f, f < 0) { if (u > s) return; u > c && (c = u); } else if (f > 0) { if (u < c) return; u < s && (s = u); } if (u = i - a, h || !(u > 0)) { if (u /= h, h < 0) { if (u < c) return; u < s && (s = u); } else if (h > 0) { if (u > s) return; u > c && (c = u); } if (u = o - a, h || !(u < 0)) { if (u /= h, h < 0) { if (u > s) return; u > c && (c = u); } else if (h > 0) { if (u < c) return; u < s && (s = u); } return c > 0 && (n[0] = l + c * f, n[1] = a + c * h), s < 1 && (t[0] = l + s * f, t[1] = a + s * h), !0; } } } } }(c, S, t, e, i, r)) ? l && (M.lineStart(), M.point(n, u), m = !1) : (g || (M.lineStart(), M.point(c[0], c[1])), M.point(S[0], S[1]), l || M.lineEnd(), m = !1); }d = n, v = u, g = l; } return w;
            };
          }(nn = +t[0][0], c = +t[0][1], s = +t[1][0], p = +t[1][1])), cn()) : nn == null ? null : [[nn, c], [s, p]];
        }, rn.scale = function (n) { return arguments.length ? (P = +n, un()) : P; }, rn.translate = function (n) { return arguments.length ? ($ = +n[0], k = +n[1], un()) : [$, k]; }, rn.center = function (n) { return arguments.length ? (R = n[0] % 360 * l, z = n[1] % 360 * l, un()) : [R * u, z * u]; }, rn.rotate = function (n) { return arguments.length ? (q = n[0] % 360 * l, W = n[1] % 360 * l, B = n.length > 2 ? n[2] % 360 * l : 0, un()) : [q * u, W * u, B * u]; }, rn.angle = function (n) { return arguments.length ? (H = n % 360 * l, un()) : H * u; }, rn.reflectX = function (n) { return arguments.length ? (I = n ? -1 : 1, un()) : I < 0; }, rn.reflectY = function (n) { return arguments.length ? (K = n ? -1 : 1, un()) : K < 0; }, rn.precision = function (n) { return arguments.length ? (v = fn(g, en = n * n), cn()) : d(en); }, rn.fitExtent = function (n, t) { return an(rn, n, t); }, rn.fitSize = function (n, t) { return (function (n, t, e) { return an(n, [[0, 0], t], e); }(rn, n, t)); }, rn.fitWidth = function (n, t) { return (function (n, t, e) { return ln(n, ((e) => { const i = +t; const r = i / (e[1][0] - e[0][0]); const o = (i - r * (e[1][0] + e[0][0])) / 2; const u = -r * e[0][1]; n.scale(150 * r).translate([o, u]); }), e); }(rn, n, t)); }, rn.fitHeight = function (n, t) { return (function (n, t, e) { return ln(n, ((e) => { const i = +t; const r = i / (e[1][1] - e[0][1]); const o = -r * e[0][0]; const u = (i - r * (e[1][1] + e[0][1])) / 2; n.scale(150 * r).translate([o, u]); }), e); }(rn, n, t)); }, function () { return i = t.apply(this, arguments), rn.invert = i.invert && on, un(); };
      }((() => t)))();
    } function gn(n, t) { return [f(t) * h(n), h(t)]; }gn.invert = (hn = v, function (n, t) { const e = d(n * n + t * t); const i = hn(e); const r = h(i); const o = f(i); return [s(n * r, e * o), v(e && t * r / e)]; }); let Sn; let yn; let mn; let En; let Mn = new _(); let _n = new _(); var wn = {
      point: g, lineStart: g, lineEnd: g, polygonStart() { wn.lineStart = xn, wn.lineEnd = Ln; }, polygonEnd() { wn.lineStart = wn.lineEnd = wn.point = g, Mn.add(a(_n)), _n = new _(); }, result() { const n = Mn / 2; return Mn = new _(), n; },
    }; function xn() { wn.point = Cn; } function Cn(n, t) { wn.point = bn, Sn = mn = n, yn = En = t; } function bn(n, t) { _n.add(En * n - mn * t), mn = n, En = t; } function Ln() { bn(Sn, yn); } let Nn; let Pn; let $n; let kn; const Tn = wn; let jn = 0; let Rn = 0; let zn = 0; let Dn = 0; let Fn = 0; let Gn = 0; let Yn = 0; let On = 0; let Xn = 0; var Zn = {
      point: qn, lineStart: An, lineEnd: Wn, polygonStart() { Zn.lineStart = Bn, Zn.lineEnd = Hn; }, polygonEnd() { Zn.point = qn, Zn.lineStart = An, Zn.lineEnd = Wn; }, result() { const n = Xn ? [Yn / Xn, On / Xn] : Gn ? [Dn / Gn, Fn / Gn] : zn ? [jn / zn, Rn / zn] : [NaN, NaN]; return jn = Rn = zn = Dn = Fn = Gn = Yn = On = Xn = 0, n; },
    }; function qn(n, t) { jn += n, Rn += t, ++zn; } function An() { Zn.point = Un; } function Un(n, t) { Zn.point = Vn, qn($n = n, kn = t); } function Vn(n, t) { const e = n - $n; const i = t - kn; const r = d(e * e + i * i); Dn += r * ($n + n) / 2, Fn += r * (kn + t) / 2, Gn += r, qn($n = n, kn = t); } function Wn() { Zn.point = qn; } function Bn() { Zn.point = In; } function Hn() { Kn(Nn, Pn); } function In(n, t) { Zn.point = Kn, qn(Nn = $n = n, Pn = kn = t); } function Kn(n, t) { const e = n - $n; const i = t - kn; let r = d(e * e + i * i); Dn += r * ($n + n) / 2, Fn += r * (kn + t) / 2, Gn += r, Yn += (r = kn * n - $n * t) * ($n + n), On += r * (kn + t), Xn += 3 * r, qn($n = n, kn = t); } const Jn = Zn; function Qn(n) { this._context = n; }Qn.prototype = {
      _radius: 4.5, pointRadius(n) { return this._radius = n, this; }, polygonStart() { this._line = 0; }, polygonEnd() { this._line = NaN; }, lineStart() { this._point = 0; }, lineEnd() { this._line === 0 && this._context.closePath(), this._point = NaN; }, point(n, t) { switch (this._point) { case 0: this._context.moveTo(n, t), this._point = 1; break; case 1: this._context.lineTo(n, t); break; default: this._context.moveTo(n + this._radius, t), this._context.arc(n, t, this._radius, 0, o); } }, result: g,
    }; let nt; let tt; let et; let it; let rt; let ot = new _(); var ut = {
      point: g, lineStart() { ut.point = lt; }, lineEnd() { nt && at(tt, et), ut.point = g; }, polygonStart() { nt = !0; }, polygonEnd() { nt = null; }, result() { const n = +ot; return ot = new _(), n; },
    }; function lt(n, t) { ut.point = at, tt = it = n, et = rt = t; } function at(n, t) { it -= n, rt -= t, ot.add(d(it * it + rt * rt)), it = n, rt = t; } const ct = ut; let st; let ft; let ht; let pt; class dt {
      constructor(n) { this._append = n == null ? vt : (function (n) { const t = Math.floor(n); if (!(t >= 0)) throw new RangeError(`invalid digits: ${n}`); if (t > 15) return vt; if (t !== st) { const n = 10 ** t; st = t, ft = function (t) { let e = 1; this._ += t[0]; for (const i = t.length; e < i; ++e) this._ += Math.round(arguments[e] * n) / n + t[e]; }; } return ft; }(n)), this._radius = 4.5, this._ = ''; }

      pointRadius(n) { return this._radius = +n, this; }

      polygonStart() { this._line = 0; }

      polygonEnd() { this._line = NaN; }

      lineStart() { this._point = 0; }

      lineEnd() { this._line === 0 && (this._ += 'Z'), this._point = NaN; }

      point(n, t) { switch (this._point) { case 0: this._append`M${n},${t}`, this._point = 1; break; case 1: this._append`L${n},${t}`; break; default: if (this._append`M${n},${t}`, this._radius !== ht || this._append !== ft) { const n = this._radius; const t = this._; this._ = '', this._append`m0,${n}a${n},${n} 0 1,1 0,${-2 * n}a${n},${n} 0 1,1 0,${2 * n}z`, ht = n, ft = this._append, pt = this._, this._ = t; } this._ += pt; } }

      result() { const n = this._; return this._ = '', n.length ? n : null; }
    } function vt(n) { let t = 1; this._ += n[0]; for (const e = n.length; t < e; ++t) this._ += arguments[t] + n[t]; } let gt; let St; let yt; let mt; var Et = {
      sphere: g, point: g, lineStart() { Et.point = _t, Et.lineEnd = Mt; }, lineEnd: g, polygonStart: g, polygonEnd: g,
    }; function Mt() { Et.point = Et.lineEnd = g; } function _t(n, t) { St = n *= l, yt = h(t *= l), mt = f(t), Et.point = wt; } function wt(n, t) { n *= l; const e = h(t *= l); const i = f(t); const r = a(n - St); const o = f(r); const u = i * h(r); const c = mt * e - yt * i * o; const p = yt * e + mt * i * o; gt.add(s(d(u * u + c * c), p)), St = n, yt = e, mt = i; } const xt = [null, null]; const Ct = { type: 'LineString', coordinates: xt }; function bt(n, t) { return xt[0] = n, xt[1] = t, (function (n) { return gt = new _(), Q(n, Et), +gt; }(Ct)); } const Lt = { Feature(n, t) { return Pt(n.geometry, t); }, FeatureCollection(n, t) { for (let e = n.features, i = -1, r = e.length; ++i < r;) if (Pt(e[i].geometry, t)) return !0; return !1; } }; const Nt = {
      Sphere() { return !0; }, Point(n, t) { return $t(n.coordinates, t); }, MultiPoint(n, t) { for (let e = n.coordinates, i = -1, r = e.length; ++i < r;) if ($t(e[i], t)) return !0; return !1; }, LineString(n, t) { return kt(n.coordinates, t); }, MultiLineString(n, t) { for (let e = n.coordinates, i = -1, r = e.length; ++i < r;) if (kt(e[i], t)) return !0; return !1; }, Polygon(n, t) { return Tt(n.coordinates, t); }, MultiPolygon(n, t) { for (let e = n.coordinates, i = -1, r = e.length; ++i < r;) if (Tt(e[i], t)) return !0; return !1; }, GeometryCollection(n, t) { for (let e = n.geometries, i = -1, r = e.length; ++i < r;) if (Pt(e[i], t)) return !0; return !1; },
    }; function Pt(n, t) { return !(!n || !Nt.hasOwnProperty(n.type)) && Nt[n.type](n, t); } function $t(n, t) { return bt(n, t) === 0; } function kt(n, e) { for (var i, r, o, u = 0, l = n.length; u < l; u++) { if ((r = bt(n[u], e)) === 0) return !0; if (u > 0 && (o = bt(n[u], n[u - 1])) > 0 && i <= o && r <= o && (i + r - o) * (1 - ((i - r) / o) ** 2) < t * o) return !0; i = r; } return !1; } function Tt(n, t) { return !!k(n.map(jt), Rt(t)); } function jt(n) { return (n = n.map(Rt)).pop(), n; } function Rt(n) { return [n[0] * l, n[1] * l]; } function zt(n, t) { return (n && Lt.hasOwnProperty(n.type) ? Lt[n.type] : Pt)(n, t); } function Dt(n, t) { if (n = (function (n) { let t; for (;t = n.sourceEvent;)n = t; return n; }(n)), void 0 === t && (t = n.currentTarget), t) { const e = t.ownerSVGElement || t; if (e.createSVGPoint) { let i = e.createSVGPoint(); return i.x = n.clientX, i.y = n.clientY, [(i = i.matrixTransform(t.getScreenCTM().inverse())).x, i.y]; } if (t.getBoundingClientRect) { const r = t.getBoundingClientRect(); return [n.clientX - r.left - t.clientLeft, n.clientY - r.top - t.clientTop]; } } return [n.pageX, n.pageY]; } const Ft = { hide(n) { n.style.visibility = 'hidden'; }, show(n, t) { n.style.visibility = 'visible', n.innerText = t; } }; const Gt = [0, 0]; const Yt = '#fff'; const Ot = '#ff571b'; const Xt = document.querySelector('#selected-countries-list-container'); new class {
      constructor(t, e, i) { this.canvas = t, this.ctx = this.canvas.getContext('2d'), this.width = this.canvas.offsetWidth, this.height = this.canvas.offsetHeight, this.tooltip = e, this.scale = 250, this.rotation = Gt, this.geojson = {}, this.state = { clickedLocation: null, hoveredLocation: null, selectedCountries: [] }, this.dragStartedTime = null, this.handleMouseDown = this.handleMouseDown.bind(this), this.handleMouseMove = this.handleMouseMove.bind(this), this.handleMouseUp = this.handleMouseUp.bind(this), this.handleZoom = this.handleZoom.bind(this), this.projection = vn(gn).scale(249.5).clipAngle(90 + n), this.geoGenerator = (function (n, t) { let e; let i; let r = 3; let o = 4.5; function u(n) { return n && (typeof o === 'function' && i.pointRadius(+o.apply(this, arguments)), Q(n, e(i))), i.result(); } return u.area = function (n) { return Q(n, e(Tn)), Tn.result(); }, u.measure = function (n) { return Q(n, e(ct)), ct.result(); }, u.bounds = function (n) { return Q(n, e(un)), un.result(); }, u.centroid = function (n) { return Q(n, e(Jn)), Jn.result(); }, u.projection = function (t) { return arguments.length ? (e = t == null ? (n = null, X) : (n = t).stream, u) : n; }, u.context = function (n) { return arguments.length ? (i = n == null ? (t = null, new dt(r)) : new Qn(t = n), typeof o !== 'function' && i.pointRadius(o), u) : t; }, u.pointRadius = function (n) { return arguments.length ? (o = typeof n === 'function' ? n : (i.pointRadius(+n), +n), u) : o; }, u.digits = function (n) { if (!arguments.length) return r; if (n == null)r = null; else { const t = Math.floor(n); if (!(t >= 0)) throw new RangeError(`invalid digits: ${n}`); r = t; } return t === null && (i = new dt(r)), u; }, u.projection(n).digits(r).context(t); }()).projection(this.projection).context(this.ctx), this.canvas.addEventListener('mousedown', this.handleMouseDown), this.canvas.addEventListener('mouseup', this.handleMouseUp), this.canvas.addEventListener('mousemove', this.handleMouseMove), this.canvas.addEventListener('wheel', this.handleZoom), this.onCountriesChange = i; }

      get clickedLocation() { return this.state.clickedLocation; }

      set clickedLocation(n) { this.state.clickedLocation = n; }

      get hoveredLocation() { return this.state.hoveredLocation; }

      set hoveredLocation(n) { this.state.hoveredLocation = n; }

      get selectedCountries() { return this.state.selectedCountries; }

      isCountrySelected(n) { return this.state.selectedCountries.findIndex(((t) => t.name === n.name)) > -1; }

      addToSelectedCountries(n) { return this.isCountrySelected(n) || this.state.selectedCountries.push(n), this.onCountriesChange(this.selectedCountries), this.state.selectedCountries; }

      removeFromSelectedCountries(n) { return this.state.selectedCountries = this.state.selectedCountries.filter(((t) => t.name !== n.name)), this.onCountriesChange(this.selectedCountries), n; }

      update() {
        const {
          projection: n, ctx: t, width: e, height: i, geojson: r, scale: o, rotation: u, geoGenerator: l, clickedLocation: a, hoveredLocation: c, tooltip: s,
        } = this; t.clearRect(0, 0, e, i), Ft.hide(s), n.fitSize([e, i], r), n.scale(o), n.rotate(u), t.beginPath(), t.strokeStyle = '#ccc', t.fillStyle = 'rgb(14, 90, 197)', l({ type: 'Sphere' }), t.stroke(), t.fill(); for (let n = 0; n < r.features.length; n += 1) { const e = r.features[n]; t.beginPath(), t.lineWidth = 0.45, t.strokeStyle = '#cbcbcb', t.fillStyle = Yt, c && zt(e, c) && (t.fillStyle = 'rgb(255, 240, 72)', Ft.show(s, e.properties.name)), this.isCountrySelected(e.properties) && (t.fillStyle = Ot), a && zt(e, a) && (this.isCountrySelected(e.properties) ? (this.removeFromSelectedCountries(e.properties), t.fillStyle = Yt) : (this.addToSelectedCountries(e.properties), t.fillStyle = Ot), this.clickedLocation = null), l(e), t.stroke(), t.fill(); }
      }

      handleMouseDown() { this.dragStartedTime = Date.now(); }

      handleMouseMove(n) { const { dragStartedTime: t, scale: e, rotation: i } = this; if (t) { const t = e > 800 ? 0.1 : 0.3; const r = n.movementX * t; const o = n.movementY * t; const [u, l] = i; this.rotation = [(u + r) % 360, (l - o) % 360]; } else { const t = Dt(n, this.canvas); this.hoveredLocation = this.projection.invert(t); } this.update(); }

      handleMouseUp(n) { const { dragStartedTime: t, projection: e } = this; if (!t || Date.now() - t < 150) { const t = Dt(n, this.canvas); this.clickedLocation = e.invert(t), this.update(); } this.dragStartedTime = null; }

      handleZoom(n) { n.preventDefault(), n.ctrlKey && (this.scale -= 0.5 * n.deltaY, this.scale > 1800 && (this.scale = 1800), this.scale < 130 && (this.scale = 130), this.update()); }

      async initialize() { const n = await fetch('https://gist.githubusercontent.com/artemplv/be8ebf292a4433944f3948b06732a6cc/raw/95e446a098596eb51cc9734e8b9e12ec8e1781d9/110m_countries.json'); this.geojson = await n.json(), this.update(); }
    }(document.querySelector('#map'), document.querySelector('#map-tooltip'), ((n) => { const t = document.createElement('ul'); for (let e = 0; e < n.length; e += 1) { const i = document.createElement('li'); i.innerText = `${n[e].name}, ${n[e].currencyCode || ''}`, t.appendChild(i); }Xt.replaceChildren(t); })).initialize();
  }());
}());
// # sourceMappingURL=main.js.map
